= VL01 Algorithms - the Basics
Ond≈ôej Havel <ondra.havel@gmail.com>
v1.0, November 2019

qwopekpk
eqweqw
wqeqweq

== Agenda

. Definition
. Algorithm Types
. Interpretation
. Sample Algorithm: Digital Root
. Complexity
. Output Space
. Broken Code
. Recursive Excercises


== Definition

An Algorithm is a sequence of steps that describes an approach to a solution of
a given problem. Every computer program that ends with a result is basically
based on a set of algorithms. Algorithms, however, are not just confined for use
in computers and can be used to solve generic tasks.


== Algorithm Types

- Divide and Conquer
- Dynamic
- Recursive
- Greedy
- Backtracking
- Randomized
- Brute Force
- and many others...

Note: algorithms commonly combine multiple algorithm types


== Divide and Conquer

Divide the algorithm into multiple parts, that contain a sub-problem ideally of
the same type. The combination of sub-solutions leads to the global solution.

Example: merge sort

image:img/vl01_mergesort.png[]

== Dynamic

These algorithms use values computed in the past to compute future results,
boosting efficiency.

Example: Fibonacci numbers

[source,perl]
----
include::code/vl01_fibo.pl[]
----

Exercise: implement a recursive algorithm


== Recursive

A special type of algorithm using a method of simplification that divides the
problem into sub-problems of the same nature.  The result of one recursion is
the input for the next recursion.  Recursion works in environments where the
algorithm is able to call itself.

image:img/vl01_recursion.jpg[]


== Backtracking

Class of algorithms for optimization tasks. The algorithm finds a partial solution
candidate on local level with hope that this candidate is a part of the solution
at the global level. Backtracking algorithms typically use recursion.

Example: routing algorithms

image:img/vl01_maze.png[width=400]


== Greedy, Randomized

=== Greedy 

Greedy usually solve optimization tasks without the guarantee of finding a
solution. The result should be a solution candidate which matches the
requirement of being 'good enough'.

Example: genetic algorithms

=== Randomized

Is a type of algorithm that uses random values in its decisions.

Example: genetic algorithms


== Brute Force

Brute force is the hard way of finding a solution by generating solution
candidates in all possible combinations. Technically, the method always finds
a solution, the real problem is the duration.

Example: password guessing

[source,perl]
----
foreach $l0 ( 'a' ... 'z' ) {
    foreach $l1 ( 'a' ... 'z' ) {
        foreach $l2 ( 'a' ... 'z' ) {
            foreach $l3 ( 'a' ... 'z' ) {
                print $l0, $l1, $l2, $l3, "\n";
            }
        }
    }
}
----

== Notation and Interpretation

- What you essentially do
	* Data transformation
	* Data comparison
	* Jump or transition to the next instruction
- Plain text preferably with clear instructions
- Usually a pseudocode of a C-like language
	* C, Perl, Java, Python, Basic


== Sample Algorithm: Digital Root

The digital root (also repeated digital sum) of a natural number in a
given number base is the (single digit) value obtained by an iterative process
of summing digits, on each iteration using the result from the previous
iteration to compute a digit sum. The process continues until a single-digit
number is reached. (source: Wikipedia)

Fixed assumption: base = 10


== Complexity

.A small overview
[width="80%",frame="topbot",options="header"]
|====================================================
|Complexity | n = 10 | n = 100 | n = 1000 | n = 10000
|log(n)     | 1 ns   | 2 ns    | 3 ns     | 4 ns
|n*log(n)   | 10 ns  | 100 ns  | 1 us     | 10 us
|n^2^       | 100 ns | 10 us   | 1 ms     | 100 ms
|n^3^       | 1 us   | 1 ms    | 1 s      | 16.7 min
|2^n^       | 1 us   | 10^24^ years | 10^302^ years | 10^3011^ years
|====================================================

== Output Domain

With the same principles and similar logic, you can work in a completely different
domain.

Try programming 3D models on https://openjscad.org

Hint: search for `openscad cheat sheet`

image:img/vl01_openscad.png[]

== Things Getting Bad

image:img/vl01_shcool.jpg[width=1000]

== Code Review

[source,c]
----
/*
 * Generate a random value between a and b, a < b.
 */
int rand_between(int a, int b)
{
    int r;

    do {
        r = rand();
    } while(r < a || r > b);

    return $r;
}
----


== Recursive Exercises

Example: factorial

[source, c]
----
int factorial(int n)
{   
    if(n <= 1)
        return 1;

    return n * factorial(n - 1);
}
----

DIY:

- Implement factorial function as a dynamic algorithm
- Lucas Numbers as a recursive algorithm
- The Tower of Hanoi
- Integer subsequence with the highest sum.

